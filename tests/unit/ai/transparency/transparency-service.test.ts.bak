/**
 * TransparencyService Tests
 * 
 * Tests for the TransparencyService class that handles agent activities,
 * thoughts, and settings.
 */

import { TransparencyService } from '../../../../src/lib/ai/transparency/transparency-service';
import * as uuid from 'uuid';
import { v4 as uuidv4 } from 'uuid';

// Mock UUID to return predictable values
jest.mock('uuid', () => {
  return {
    v4: jest.fn().mockImplementation(() => 'mocked-uuid')
  };
});

// Test configuration
const config = {
  organizationId: '123e4567-e89b-12d3-a456-426614174000',
  testAgentId: '123e4567-e89b-12d3-a456-426614174001',
  testActivityId: '123e4567-e89b-12d3-a456-426614174002',
  testUserId: '123e4567-e89b-12d3-a456-426614174003',
  testMemoryId: '123e4567-e89b-12d3-a456-426614174004',
};

// Use test config data
const mockOrganizationId = config.organizationId;
const mockAgentId = config.testAgentId;
const mockActivityId = config.testActivityId;
const mockUserId = config.testUserId;
const mockMemoryId = config.testMemoryId;

// Mock console.error to prevent test output pollution
const originalConsoleError = console.error;
console.error = jest.fn();

describe('TransparencyService', () => {
  let transparencyService: TransparencyService;
  let mockSupabaseClient: any;
  
  beforeEach(() => {
    // Reset UUID mock
    (uuidv4 as jest.Mock).mockReset();
    (uuidv4 as jest.Mock).mockReturnValue('mocked-uuid');
    
    // Create a more sophisticated mock that properly supports all method chaining patterns
    mockSupabaseClient = {
      from: jest.fn().mockImplementation(() => {
        // Create terminal methods that return response objects
        const mockResponse = {
          data: null,
          error: null
        };
        
        // Create a select chain that can be reused
        const selectChain = {
          eq: jest.fn().mockReturnThis(),
          is: jest.fn().mockReturnThis(),
          neq: jest.fn().mockReturnThis(),
          gt: jest.fn().mockReturnThis(),
          lt: jest.fn().mockReturnThis(),
          gte: jest.fn().mockReturnThis(),
          lte: jest.fn().mockReturnThis(),
          like: jest.fn().mockReturnThis(),
          ilike: jest.fn().mockReturnThis(),
          order: jest.fn().mockReturnThis(),
          limit: jest.fn().mockReturnThis(),
          range: jest.fn().mockReturnThis(),
          single: jest.fn().mockResolvedValue(mockResponse),
          maybeSingle: jest.fn().mockResolvedValue(mockResponse)
        };
        
        // Create insert chain with proper select().single() support
        const insertSingleChain = {
          single: jest.fn().mockResolvedValue(mockResponse)
        };
        
        const insertSelectChain = {
          select: jest.fn().mockReturnValue(insertSingleChain)
        };
        
        // Create update chain with proper method chaining
        const updateChain = {
          eq: jest.fn().mockReturnThis(),
          select: jest.fn().mockReturnValue({
            single: jest.fn().mockResolvedValue(mockResponse)
          })
        };
        
        // Return the complete mock object with all necessary methods
        return {
          select: jest.fn().mockReturnValue(selectChain),
          insert: jest.fn().mockReturnValue(insertSelectChain),
          update: jest.fn().mockReturnValue(updateChain),
          delete: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnThis()
          }),
          maybeSingle: jest.fn().mockResolvedValue(mockResponse)
        };
      })
    };

    // Mock UUID
    (uuidv4 as jest.Mock).mockReturnValue('mocked-uuid');
    
    // Create service instance
    transparencyService = new TransparencyService(mockSupabaseClient, mockOrganizationId);
    
    // Spy on console.error
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });
  
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  afterAll(() => {
    // Restore console.error
    console.error = originalConsoleError;
  });
  
  describe('logActivity', () => {
    it('should log an activity successfully', async () => {
      // Setup
      const activityData = {
        agentId: mockAgentId,
        activityType: 'process_message',
        description: 'Processing message',
        relatedEntityType: 'contact',
        relatedEntityId: 'contact-123',
        metadata: { key: 'value' }
      };
      
      const mockResponse = {
        data: {
          id: 'mocked-uuid',
          organization_id: mockOrganizationId,
          agent_id: mockAgentId,
          activity_type: 'process_message',
          description: 'Processing message',
          related_entity_type: 'contact',
          related_entity_id: 'contact-123',
          metadata: { key: 'value' }
        },
        error: null
      };
      
      // UUID is already mocked globally
      
      // Set up the mock chain with proper select method
      const mockSingleFn = jest.fn().mockResolvedValue(mockResponse);
      const mockSelectFn = jest.fn().mockReturnValue({ single: mockSingleFn });
      const mockInsertFn = jest.fn().mockReturnValue({ select: mockSelectFn });
      mockSupabaseClient.from.mockReturnValue({
        insert: mockInsertFn
      });
      
      // Execute
      const result = await transparencyService.logActivity(activityData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_activities');
      expect(mockInsertFn).toHaveBeenCalledWith({
        id: 'mocked-uuid',
        organization_id: mockOrganizationId,
        agent_id: mockAgentId,
        activity_type: 'process_message',
        description: 'Processing message',
        related_entity_type: 'contact',
        related_entity_id: 'contact-123',
        metadata: { key: 'value' },
        created_at: expect.any(String)
      });
      expect(result).toEqual(mockResponse.data);
    });
    
    it('should handle errors when logging an activity', async () => {
      // Setup
      const activityData = {
        agentId: mockAgentId,
        activityType: 'process_message',
        description: 'Processing message'
      };
      
      // Create a mock error object
      const mockErrorObj = { message: 'Database error' };
      
      // Set up the mock response
      const mockResponse = {
        data: null,
        error: mockErrorObj
      };
      
      // Set up the mock chain with proper select method
      const mockSingleFn = jest.fn().mockResolvedValue(mockResponse);
      const mockSelectFn = jest.fn().mockReturnValue({ single: mockSingleFn });
      const mockInsertFn = jest.fn().mockReturnValue({ select: mockSelectFn });
      mockSupabaseClient.from.mockImplementation((table: string) => {
        if (table === 'ai_agent_activities') {
          return {
            insert: mockInsertFn
          };
        }
        return {
          select: jest.fn().mockReturnThis(),
          insert: jest.fn().mockReturnThis(),
          update: jest.fn().mockReturnThis(),
          delete: jest.fn().mockReturnThis()
        };
      });
      
      // Execute
      const result = await transparencyService.logActivity(activityData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_activities');
      expect(console.error).toHaveBeenCalledWith('Failed to log agent activity:', mockErrorObj);
      expect(result).toBeNull();
    });
    
    it('should handle Supabase errors', async () => {
      // Setup
      const activityData = {
        agentId: mockAgentId,
        activityType: 'process_message',
        description: 'Processing message'
      };
      
      // Create a mock error object
      const mockErrorObj = { message: 'Database error' };
      
      // Simulate a Supabase error
      mockSupabaseClient.from.mockImplementation(() => {
        throw mockErrorObj;
      });
      
      // Execute
      const result = await transparencyService.logActivity(activityData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_activities');
      expect(console.error).toHaveBeenCalledWith('Error logging agent activity:', mockErrorObj);
      expect(result).toBeNull();
    });
  });
  
  
  describe('getAgentActivities', () => {
    it('should get activities for an agent', async () => {
      // Setup
      const mockActivities = [
        { id: 'activity-1', agent_id: mockAgentId, activity_type: 'process_message' },
        { id: 'activity-2', agent_id: mockAgentId, activity_type: 'response_generated' }
      ];
      
      const mockResponse = {
        data: mockActivities,
        error: null
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
              order: jest.fn().mockReturnValue({
                range: jest.fn().mockResolvedValue(mockResponse)
              })
            })
          })
        })
      });
      
      // Execute
      const result = await transparencyService.getAgentActivities(mockAgentId, 10, 0);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_activities');
      expect(mockSupabaseClient.from().select).toHaveBeenCalledWith('*');
      expect(mockSupabaseClient.from().select().eq).toHaveBeenCalledWith('agent_id', mockAgentId);
      expect(mockSupabaseClient.from().select().eq().eq).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockSupabaseClient.from().select().eq().eq().order).toHaveBeenCalledWith('created_at', { ascending: false });
      expect(mockSupabaseClient.from().select().eq().eq().order().range).toHaveBeenCalledWith(0, 9);
      expect(result).toEqual(mockActivities);
    });
    
    it('should handle errors when getting activities', async () => {
      // Setup
      const mockResponse = {
        data: null,
        error: { message: 'Database error' }
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
              order: jest.fn().mockReturnValue({
                range: jest.fn().mockResolvedValue(mockResponse)
              })
            })
          })
        })
      });
      
      // Execute
      const result = await transparencyService.getAgentActivities(mockAgentId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_activities');
      expect(console.error).toHaveBeenCalledWith('Failed to get agent activities:', mockResponse.error);
      expect(result).toEqual([]);
    });
  });
  
  describe('getActivityThoughts', () => {
    it('should get thoughts for an activity', async () => {
      // Setup
      const mockThoughts = [
        { id: 'thought-1', activity_id: mockActivityId, thought_step: 1 },
        { id: 'thought-2', activity_id: mockActivityId, thought_step: 2 }
      ];
      
      const mockResponse = {
        data: mockThoughts,
        error: null
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
              order: jest.fn().mockResolvedValue(mockResponse)
            })
          })
        })
      });
      
      // Execute
      const result = await transparencyService.getActivityThoughts(mockActivityId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_thoughts');
      expect(mockSupabaseClient.from().select).toHaveBeenCalledWith('*');
      expect(mockSupabaseClient.from().select().eq).toHaveBeenCalledWith('activity_id', mockActivityId);
      expect(mockSupabaseClient.from().select().eq().eq).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockSupabaseClient.from().select().eq().eq().order).toHaveBeenCalledWith('thought_step', { ascending: true });
      expect(result).toEqual(mockThoughts);
    });
    
    it('should handle errors when getting thoughts', async () => {
      // Setup
      const mockResponse = {
        data: null,
        error: { message: 'Database error' }
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockReturnValue({
              order: jest.fn().mockResolvedValue(mockResponse)
            })
          })
        })
      });
      
      // Execute
      const result = await transparencyService.getActivityThoughts(mockActivityId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_thoughts');
      expect(console.error).toHaveBeenCalledWith('Failed to get activity thoughts:', mockResponse.error);
      expect(result).toEqual([]);
    });
  });
  
  describe('updateSetting', () => {
    it('should handle error when getting setting', async () => {
      // Arrange
      const settingData = {
        settingKey: 'test-setting',
        settingValue: { enabled: true },
        userId: undefined,
        agentId: mockAgentId
      };
      
      const mockResponse = {
        data: null,
        error: { message: 'Database error' }
      };
      
      // Set up the mock chain
      const mockMaybeSingle = jest.fn().mockResolvedValue(mockResponse);
      const mockIs2 = jest.fn().mockReturnValue({ maybeSingle: mockMaybeSingle });
      const mockIs1 = jest.fn().mockReturnValue({ is: mockIs2 });
      const mockEq3 = jest.fn().mockReturnValue({ is: mockIs1 });
      const mockEq2 = jest.fn().mockReturnValue({ eq: mockEq3 });
      const mockEq1 = jest.fn().mockReturnValue({ eq: mockEq2 });
      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq1 });
      
      mockSupabaseClient.from.mockImplementation((table: string) => {
        if (table === 'ai_agent_settings') {
          return {
            select: mockSelect
          };
        }
        return {
          select: jest.fn().mockReturnThis(),
          insert: jest.fn().mockReturnThis(),
          update: jest.fn().mockReturnThis(),
          delete: jest.fn().mockReturnThis()
        };
      });
      
      // Execute
      const result = await transparencyService.updateSetting(settingData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_settings');
      expect(mockSelect).toHaveBeenCalledWith('id');
      expect(mockEq1).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockEq2).toHaveBeenCalledWith('setting_key', settingData.settingKey);
      expect(mockIs1).toHaveBeenCalledWith('user_id', undefined);
      expect(mockIs2).toHaveBeenCalledWith('agent_id', settingData.agentId);
      expect(mockMaybeSingle).toHaveBeenCalled();
      
      expect(console.error).toHaveBeenCalledWith('Error updating agent setting:', mockResponse.error);
      expect(result).toBeNull();
    });
    
    it('should update an existing setting', async () => {
      // Arrange
      const settingData = {
        settingKey: 'test-setting',
        settingValue: { enabled: true },
        userId: undefined,
        agentId: mockAgentId
      };
      
      const existingSetting = {
        id: 'existing-setting-id'
      };
      
      const getResponse = {
        data: existingSetting,
        error: null
      };
      
      const updateResponse = {
        data: [{ id: 'existing-setting-id', setting_value: { enabled: true } }],
        error: null
      };
      
      // Set up the mock chain for select query
      const mockMaybeSingle = jest.fn().mockResolvedValue(getResponse);
      const mockIs2 = jest.fn().mockReturnValue({ maybeSingle: mockMaybeSingle });
      const mockIs1 = jest.fn().mockReturnValue({ is: mockIs2 });
      const mockEq3 = jest.fn().mockReturnValue({ is: mockIs1 });
      const mockEq2 = jest.fn().mockReturnValue({ eq: mockEq3 });
      const mockEq1 = jest.fn().mockReturnValue({ eq: mockEq2 });
      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq1 });
      
      // Set up the mock chain for update query
      const mockSingle = jest.fn().mockResolvedValue(updateResponse);
      const mockSelect2 = jest.fn().mockReturnValue({ single: mockSingle });
      const mockEq4 = jest.fn().mockReturnValue({ select: mockSelect2 });
      const mockUpdate = jest.fn().mockReturnValue({ eq: mockEq4 });
      
      mockSupabaseClient.from.mockImplementation((table: string) => {
        if (table === 'ai_agent_settings') {
          return {
            select: mockSelect,
            update: mockUpdate
          };
        }
        return {
          select: jest.fn().mockReturnThis(),
          insert: jest.fn().mockReturnThis(),
          update: jest.fn().mockReturnThis(),
          delete: jest.fn().mockReturnThis()
        };
      });
      
      // Execute
      const result = await transparencyService.updateSetting(settingData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_settings');
      expect(mockSelect).toHaveBeenCalledWith('id');
      expect(mockEq1).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockEq2).toHaveBeenCalledWith('setting_key', settingData.settingKey);
      expect(mockIs1).toHaveBeenCalledWith('user_id', undefined);
      expect(mockIs2).toHaveBeenCalledWith('agent_id', settingData.agentId);
      expect(mockMaybeSingle).toHaveBeenCalled();
      
      expect(mockUpdate).toHaveBeenCalledWith({
        setting_value: settingData.settingValue,
        updated_at: expect.any(String)
      });
      expect(mockEq4).toHaveBeenCalledWith('id', existingSetting.id);
      expect(mockSelect2).toHaveBeenCalled();
      expect(mockSingle).toHaveBeenCalled();
      
      expect(result).toEqual(updateResponse.data);
    });
    
    it('should create a new setting if it does not exist', async () => {
      // Arrange
      const settingData = {
        settingKey: 'test-setting',
        settingValue: { enabled: true },
        userId: mockUserId,
        agentId: undefined
      };
      
      const getResponse = {
        data: null,
        error: null
      };
      
      const insertResponse = {
        data: [{ id: 'new-setting-id', setting_value: { enabled: true } }],
        error: null
      };
      
      // Set up the mock chain for select query
      const mockMaybeSingle = jest.fn().mockResolvedValue(getResponse);
      const mockIs2 = jest.fn().mockReturnValue({ maybeSingle: mockMaybeSingle });
      const mockIs1 = jest.fn().mockReturnValue({ is: mockIs2 });
      const mockEq3 = jest.fn().mockReturnValue({ is: mockIs1 });
      const mockEq2 = jest.fn().mockReturnValue({ eq: mockEq3 });
      const mockEq1 = jest.fn().mockReturnValue({ eq: mockEq2 });
      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq1 });
      
      const mockInsert = jest.fn().mockResolvedValue(insertResponse);
      
      mockSupabaseClient.from.mockImplementation((table: string) => {
        if (table === 'ai_agent_settings') {
          return {
            select: mockSelect,
            insert: mockInsert
          };
        }
        return {};
      });
      
      // Execute
      const result = await transparencyService.updateSetting(settingData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_settings');
      expect(mockSelect).toHaveBeenCalledWith('id');
      expect(mockEq1).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockEq2).toHaveBeenCalledWith('setting_key', settingData.settingKey);
      expect(mockIs1).toHaveBeenCalledWith('user_id', settingData.userId);
      expect(mockIs2).toHaveBeenCalledWith('agent_id', undefined);
      expect(mockMaybeSingle).toHaveBeenCalled();
      
      expect(mockInsert).toHaveBeenCalledWith({
        id: 'mocked-uuid',
        organization_id: mockOrganizationId,
        user_id: settingData.userId,
        agent_id: settingData.agentId,
        setting_key: settingData.settingKey,
        setting_value: settingData.settingValue,
        created_at: expect.any(String),
        updated_at: expect.any(String)
      });
      
      expect(result).toEqual(insertResponse.data);
    });
    
    it('should handle error when inserting setting', async () => {
      // Arrange
      const settingData = {
        settingKey: 'test-setting',
        settingValue: { enabled: true },
        userId: mockUserId,
        agentId: undefined
      };
      
      const getResponse = {
        data: null,
        error: null
      };
      
      const insertResponse = {
        data: null,
        error: { message: 'Database error' }
      };
      
      // Set up the mock chain for select query
      const mockMaybeSingle = jest.fn().mockResolvedValue(getResponse);
      const mockIs2 = jest.fn().mockReturnValue({ maybeSingle: mockMaybeSingle });
      const mockIs1 = jest.fn().mockReturnValue({ is: mockIs2 });
      const mockEq3 = jest.fn().mockReturnValue({ is: mockIs1 });
      const mockEq2 = jest.fn().mockReturnValue({ eq: mockEq3 });
      const mockEq1 = jest.fn().mockReturnValue({ eq: mockEq2 });
      const mockSelect = jest.fn().mockReturnValue({ eq: mockEq1 });
      
      const mockInsert = jest.fn().mockResolvedValue(insertResponse);
      
      mockSupabaseClient.from.mockImplementation((table: string) => {
        if (table === 'ai_agent_settings') {
          return {
            select: mockSelect,
            insert: mockInsert
          };
        }
        return {};
      });
      
      // Execute
      const result = await transparencyService.updateSetting(settingData);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_settings');
      expect(mockSelect).toHaveBeenCalledWith('id');
      expect(mockEq1).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockEq2).toHaveBeenCalledWith('setting_key', settingData.settingKey);
      expect(mockIs1).toHaveBeenCalledWith('user_id', settingData.userId);
      expect(mockIs2).toHaveBeenCalledWith('agent_id', undefined);
      expect(mockMaybeSingle).toHaveBeenCalled();
      
      expect(mockInsert).toHaveBeenCalledWith({
        id: 'mocked-uuid',
        organization_id: mockOrganizationId,
        user_id: settingData.userId,
        agent_id: settingData.agentId,
        setting_key: settingData.settingKey,
        setting_value: settingData.settingValue,
        created_at: expect.any(String),
        updated_at: expect.any(String)
      });
      
      expect(console.error).toHaveBeenCalledWith('Error updating agent setting:', insertResponse.error);
      expect(result).toBeNull();
    });
  });
  
  describe('getSettings', () => {
    it('should get settings for an agent', async () => {
      // Setup
      const mockSettings = [
        { setting_key: 'activity_logging_enabled', setting_value: true },
        { setting_key: 'thought_logging_enabled', setting_value: false }
      ];
      
      const mockResponse = {
        data: mockSettings,
        error: null
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockResponse)
          })
        })
      });
      
      // Execute
      const result = await transparencyService.getSettings(mockAgentId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_settings');
      expect(mockSupabaseClient.from().select).toHaveBeenCalledWith('*');
      expect(mockSupabaseClient.from().select().eq).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(mockSupabaseClient.from().select().eq().eq).toHaveBeenCalledWith('agent_id', mockAgentId);
      expect(result).toEqual(mockSettings);
    });
    
    it('should handle errors when getting settings', async () => {
      // Setup
      const mockResponse = {
        data: null,
        error: { message: 'Database error' }
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        select: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockResponse)
          })
        })
      });
      
      // Execute
      const result = await transparencyService.getSettings(mockAgentId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_agent_settings');
      expect(console.error).toHaveBeenCalledWith('Failed to get agent settings:', mockResponse.error);
      expect(result).toEqual([]);
    });
  });
  
  describe('deleteMemory', () => {
    it('should delete a memory successfully', async () => {
      // Setup
      const mockResponse = {
        data: {},
        error: null
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        delete: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockResponse)
          })
        })
      });
      
      // Execute
      const result = await transparencyService.deleteMemory(mockMemoryId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_memories');
      expect(mockSupabaseClient.from().delete).toHaveBeenCalled();
      expect(mockSupabaseClient.from().delete().eq).toHaveBeenCalledWith('id', mockMemoryId);
      expect(mockSupabaseClient.from().delete().eq().eq).toHaveBeenCalledWith('organization_id', mockOrganizationId);
      expect(result).toBe(true);
    });
    
    it('should handle errors when deleting a memory', async () => {
      // Setup
      const mockResponse = {
        data: null,
        error: { message: 'Database error' }
      };
      
      // Set up the mock chain
      mockSupabaseClient.from.mockReturnValue({
        delete: jest.fn().mockReturnValue({
          eq: jest.fn().mockReturnValue({
            eq: jest.fn().mockResolvedValue(mockResponse)
          })
        })
      });
      
      // Execute
      const result = await transparencyService.deleteMemory(mockMemoryId);
      
      // Assert
      expect(mockSupabaseClient.from).toHaveBeenCalledWith('ai_memories');
      expect(console.error).toHaveBeenCalledWith('Failed to delete memory:', mockResponse.error);
      expect(result).toBe(false);
    });
  });
});
